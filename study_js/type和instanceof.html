<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
	</body>
	<script type="text/javascript">
		console.log(typeof(123)) //number
		console.log(typeof(true)) //boolean
		console.log(typeof('mdd')) //string
		console.log(typeof(undefined)) //undefined


		console.log(typeof(null)) // object
		//计数机typeof 返回的数据类型 根据机器码的后三位 01011 检测
		// 当机器码的后三位是000=>obiect
		//而null 在计算机里存储的全都是000...000 => object


		console.log(typeof([])) // object 引用类型数据返回object
		console.log(typeof(new Date())) // object  通过new Date()创建一个对象也是object
		console.log(typeof({})) // object


		console.log(typeof(function() {})) // function
		console.log(typeof(Array)) // function
		//typeof 判断引用类型 会返回object 但是其会把 object分为两种:function 和object
		//在js设计过程中在object 引用类型里面定义了一个内部方法 [[call]]
		//其会去判断引用类型上面有没有call方法,有则返回function


		var str = 'Mooc' //开辟的是栈空间
		console.log(str)
		console.log(typeof('MOOC')) //string
		console.log('___________________________')
		var str1 = new String('MOOC') //通过new 去new一个构造函数，是实例化出来的一个对象 
		console.log(str1) //{}
		console.log(typeof(str1)) //object

		//————————————————————————————————————————————————————————————————————————————
		// instanceof 检测 返回值为boolean
		// A 对象是否是由B对象 实例化后出来的
		// A instanceof B
		console.log([] instanceof Array) //true
		console.log({}instanceof Object) //true
		console.log(new Date() instanceof Date) //true
		function Person() {}
		console.log(new Person() instanceof Person)

		console.log([] instanceof Object)     //true
		console.log(new Date() instanceof Object) //true
		console.log(new Person instanceof Object) //true
		
		// instanceof 是顺着原型链检测 A instanceof B  =>true再向上找 B instanceof C =>true
		 //则可以推导 A instanceof C
		 
		 
			console.log(Object.prototype.toString.call('1'))
			console.log(Object.prototype.toString.call([]))
	</script>
</html>
